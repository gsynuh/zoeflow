# Terminology (ZoeFlow)

This project uses a few similar-sounding words. This document defines them so code, UI, and docs stay aligned.

## Core concepts

- **Flow**: A user-facing concept for what is essentially a graph that can run with the wrapper and engine. A user-saved project unit (id, name, timestamps) that contains a graph and can be run. Flow Library, Flow management, etc. are correct user-facing terms.
- **Graph**: The technical data structure `{ nodes, edges }` that defines connectivity and execution ordering. Engine code uses Graph for the technical representation.
- **Node / Edge / Port**: Graph primitives used by the engine.
- **Run**: The standard term for "conversation run" or "completion run". A run executes graph logic. One invocation of a flow/graph with a specific user message and optional chat history. Prefer "Run" terminology in user-facing contexts and as the standard term. "Execution" may be acceptable for internal implementation details (e.g., ExecutionState, ExecutionRuntime) but should be clearly internal/technical. Function names like `executeGraph` are acceptable as verb forms.

## UI vs engine

- **Canvas graph**: The React Flow representation (UI nodes/edges with positions/handles). It is converted into an engine graph before execution.
- **Chat**: The UI conversation history between the user and assistants.
- **Context messages**: Messages produced by “Message” nodes (system/user) that are injected into the completion request (distinct from chat history).

## Naming rules (code)

- Use `Flow` for user-facing persisted entities that include metadata (what users save, load, manage).
- Use `Graph` for `{ nodes, edges }` only (technical data structure).
- Prefer `Zoe*` types inside `src/zoeflow/*` (engine domain); reserve `ZoeFlow` mainly for product/UI text. "ZoeFlow" in comments when referring to the product/system is acceptable.
- Use `ReactFlow` in names when something is specific to React Flow (e.g. node/edge wrappers).

## Node strings (UI)

- **Title**: The node name shown on the node (usually `definition.label`). Some nodes can override this for the canvas (ex: "User Message" vs "System Message").
- **Label**: Optional user-defined label shown under the title. Some nodes intentionally hide it on the canvas (ex: Start/End).
- **Description**: Short help text used in the node palette. Not shown on the node itself.

## Node categories

Every node belongs to a **category**. Categories are used to group nodes in the "Add node" palette and to style nodes consistently in the canvas.

- **Boundaries**: Core flow endpoints (Start, End). This category will likely never expand beyond Start and End nodes. Shown as a separate palette section and does not apply canvas color styling.
- **Control**: Flow control and routing (If/Else, Switch).
- **Constant**: Provides values to be read by later nodes (Message).
- **Function**: Client-side data processing (Redact, Transform).
- **Tool**: Provides tools/functions to Completion nodes.
- **Agent**: Calls an external model/API (Completion, Guardrails).

## Vector store and RAG

- **Vector Store**: A server-side JSON-backed storage system that stores text entries with their embeddings. Entries can be queried by semantic similarity using embedding vectors.
- **Embedding**: A numerical vector representation of text that captures semantic meaning, allowing similarity search.
- **RAG (Retrieval-Augmented Generation)**: A technique where a Completion node retrieves relevant context from a vector store before generating a response. The RAG node provides a `rag_search` tool and query-writing guidance to connected Completion nodes.
- **Store ID**: Identifier for a specific vector store instance (defaults to "default"). In code, use camelCase `storeId`. In UI/docs, use "Store ID" (capitalized). For types, use PascalCase `VectorStore`. For API routes, use lowercase `vectorstore`.
- **Top K**: The number of most similar results to return from a vector store query.

## Token counting and costs

- **Token count**: The number of tokens used in API calls, as reported by OpenRouter/OpenAI. Token counts include:
  - Content tokens: The actual text content of messages
  - Formatting overhead: Role markers, message boundaries, and other structural tokens added by the API (typically ~4-5 tokens per message)
  - **Prompt tokens (input)**: Tokens sent to the model, including all messages in the request plus formatting overhead. This is the billable input token count.
  - **Completion tokens (output)**: Tokens generated by the model in its response.
  - **Context usage**: The percentage of the model's context window used, calculated as `(prompt tokens + completion tokens) / max context length`. All API calls in a thread (including hidden/internal messages) count toward context usage.

## File naming conventions

- **Node files**: Use lowercase for node-specific files:
  - `definition.ts` - Node definition metadata
  - `execute.ts` - Node executor implementation
  - `collection.ts` - Tool node collection (optional, for tool nodes)
  - `developer.ts` - Developer tool definition (optional, for tool nodes)
- **Components**: Use PascalCase (e.g., `StandardNode.tsx`)
- **Type files**: Use camelCase (e.g., `types.ts`)
- **Node directory structure**: `src/zoeflow/nodes/<nodeName>/` where `<nodeName>` is lowercase camelCase
