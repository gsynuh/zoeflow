import { resolvePorts } from "@/zoeflow/engine/validation";
import { getDeveloperToolDefinition } from "@/zoeflow/nodes/tool/developer";
import { getNodeDefinition } from "@/zoeflow/registry";
import {
  ZoeNodeID,
  type ZoeCompletionNodeData,
  type ZoeEdge,
  type ZoeGraph,
  type ZoeIfElseNodeData,
  type ZoeMessageNodeData,
  type ZoeNode,
  type ZoeRedactNodeData,
  type ZoeStartNodeData,
  type ZoeSwitchNodeData,
  type ZoeToolNodeData,
  type ZoeTransformNodeData,
} from "@/zoeflow/types";

/**
 * Generate executable TypeScript code that represents the execution flow of a ZoeFlow graph.
 *
 * @param graph - Graph snapshot to render.
 */
export function generateTypeScriptPreview(graph: ZoeGraph): string {
  const startNode = graph.nodes.find((node) => node.type === ZoeNodeID.Start);
  if (!startNode) {
    return "// Error: No Start node found in graph";
  }

  const nodesById = new Map(graph.nodes.map((node) => [node.id, node]));
  const edgesBySource = buildEdgesBySource(graph.edges);
  const visited = new Set<string>();
  const lines: string[] = [];

  lines.push("// ZoeFlow Execution Flow");
  lines.push("// Generated by: Preview as TypeScript");
  lines.push("// This code represents the execution flow of your graph");
  lines.push("");
  lines.push("async function executeFlow(userMessage: string) {");
  lines.push("  // Execution state");
  lines.push("  let payload: unknown = userMessage;");
  lines.push(
    "  let contextMessages: Array<{ role: string; content: string; priority: number }> = [];",
  );
  lines.push("  let vars: Record<string, unknown> = {};");
  lines.push(
    "  let conversation: Array<{ role: string; content: string }> = [];",
  );
  lines.push("");

  const indent = "  ";
  traverseAndGenerate(
    startNode,
    nodesById,
    edgesBySource,
    visited,
    lines,
    indent,
  );

  lines.push("");
  lines.push("  return payload;");
  lines.push("}");

  return lines.join("\n");
}

/**
 * Traverse the graph and generate code for each node.
 */
function traverseAndGenerate(
  node: ZoeNode,
  nodesById: Map<string, ZoeNode>,
  edgesBySource: Map<string, ZoeEdge[]>,
  visited: Set<string>,
  lines: string[],
  indent: string,
): void {
  if (visited.has(node.id)) {
    lines.push(`${indent}// Warning: Cycle detected at node ${node.id}`);
    return;
  }
  visited.add(node.id);

  generateNodeCode(node, lines, indent);

  const outgoing = edgesBySource.get(node.id) ?? [];
  if (outgoing.length === 0) {
    return;
  }

  if (node.type === ZoeNodeID.IfElse) {
    const data = node.data as ZoeIfElseNodeData;
    const thenEdge = outgoing.find((e) => e.sourcePort === "then");
    const elseEdge = outgoing.find((e) => e.sourcePort === "else");

    lines.push("");
    lines.push(
      `${indent}// Branch based on condition: ${data.condition || "true"}`,
    );
    lines.push(`${indent}if (${data.condition || "true"}) {`);
    if (thenEdge) {
      const nextNode = nodesById.get(thenEdge.target);
      if (nextNode) {
        traverseAndGenerate(
          nextNode,
          nodesById,
          edgesBySource,
          visited,
          lines,
          indent + "  ",
        );
      }
    }
    lines.push(`${indent}} else {`);
    if (elseEdge) {
      const nextNode = nodesById.get(elseEdge.target);
      if (nextNode) {
        traverseAndGenerate(
          nextNode,
          nodesById,
          edgesBySource,
          visited,
          lines,
          indent + "  ",
        );
      }
    }
    lines.push(`${indent}}`);
  } else if (node.type === ZoeNodeID.Switch) {
    const data = node.data as ZoeSwitchNodeData;
    const definition = getNodeDefinition(node.type);
    const outputPorts = resolvePorts(definition.outputPorts, node.data);
    const caseLabels = data.caseLabels?.split("\n").filter(Boolean) ?? [];

    lines.push("");
    lines.push(
      `${indent}// Switch on expression: ${data.expression || "value"}`,
    );
    lines.push(`${indent}const switchValue = ${data.expression || "payload"};`);
    lines.push(`${indent}switch (switchValue) {`);

    for (let i = 0; i < outputPorts.length; i++) {
      const port = outputPorts[i];
      const caseLabel = caseLabels[i] || `case${i + 1}`;
      const edge = outgoing.find((e) => e.sourcePort === port.id);

      lines.push(`${indent}  case ${i}: // ${caseLabel}`);
      if (edge) {
        const nextNode = nodesById.get(edge.target);
        if (nextNode) {
          lines.push(`${indent}    {`);
          traverseAndGenerate(
            nextNode,
            nodesById,
            edgesBySource,
            visited,
            lines,
            indent + "      ",
          );
          lines.push(`${indent}      break;`);
          lines.push(`${indent}    }`);
        }
      }
    }
    lines.push(`${indent}}`);
  } else {
    // Sequential execution - follow first edge
    const sortedEdges = [...outgoing].sort((a, b) => {
      // Sort by sourcePort if available
      if (a.sourcePort && b.sourcePort) {
        return a.sourcePort.localeCompare(b.sourcePort);
      }
      return a.id.localeCompare(b.id);
    });

    for (const edge of sortedEdges) {
      const nextNode = nodesById.get(edge.target);
      if (nextNode) {
        lines.push("");
        traverseAndGenerate(
          nextNode,
          nodesById,
          edgesBySource,
          visited,
          lines,
          indent,
        );
        break; // Only follow first edge for sequential nodes
      }
    }
  }
}

/**
 * Generate code for executing a specific node.
 */
function generateNodeCode(
  node: ZoeNode,
  lines: string[],
  indent: string,
): void {
  const label = node.data.label || node.data.title || node.id;

  lines.push(`${indent}// ${node.type}: ${label}`);

  switch (node.type) {
    case ZoeNodeID.Start: {
      const data = node.data as ZoeStartNodeData;
      if (data.defaultUserPrompt) {
        lines.push(
          `${indent}payload = ${JSON.stringify(data.defaultUserPrompt)};`,
        );
      }
      break;
    }

    case ZoeNodeID.Completion: {
      const data = node.data as ZoeCompletionNodeData;
      lines.push(
        `${indent}const completionResponse = await fetch("/api/v1/completion", {`,
      );
      lines.push(`${indent}  method: "POST",`);
      lines.push(`${indent}  headers: { "Content-Type": "application/json" },`);
      lines.push(`${indent}  body: JSON.stringify({`);
      lines.push(`${indent}    model: ${JSON.stringify(data.model)},`);
      if (data.temperature !== undefined) {
        lines.push(`${indent}    temperature: ${data.temperature},`);
      }
      if (data.systemPrompt) {
        lines.push(`${indent}    messages: [`);
        lines.push(
          `${indent}      { role: "system", content: ${JSON.stringify(data.systemPrompt)} },`,
        );
        lines.push(
          `${indent}      ...contextMessages.map(m => ({ role: m.role, content: m.content })),`,
        );
        lines.push(`${indent}      { role: "user", content: String(payload) }`);
        lines.push(`${indent}    ],`);
      } else {
        lines.push(`${indent}    messages: [`);
        lines.push(
          `${indent}      ...contextMessages.map(m => ({ role: m.role, content: m.content })),`,
        );
        lines.push(`${indent}      { role: "user", content: String(payload) }`);
        lines.push(`${indent}    ],`);
      }
      if (data.useTools) {
        lines.push(
          `${indent}    tools: [], // Tools would be collected from connected Tool nodes`,
        );
      }
      lines.push(`${indent}  }),`);
      lines.push(`${indent}});`);
      lines.push(
        `${indent}const completionData = await completionResponse.json();`,
      );
      lines.push(
        `${indent}payload = completionData.choices?.[0]?.message?.content ?? "";`,
      );
      lines.push(
        `${indent}conversation.push({ role: "user", content: String(payload) });`,
      );
      lines.push(
        `${indent}conversation.push({ role: "assistant", content: String(payload) });`,
      );
      break;
    }

    case ZoeNodeID.Message: {
      const data = node.data as ZoeMessageNodeData;
      lines.push(`${indent}contextMessages.push({`);
      lines.push(`${indent}  role: ${JSON.stringify(data.role)},`);
      lines.push(`${indent}  content: ${JSON.stringify(data.text || "")},`);
      lines.push(`${indent}  priority: ${data.priority ?? 0}`);
      lines.push(`${indent}});`);
      break;
    }

    case ZoeNodeID.Transform: {
      const data = node.data as ZoeTransformNodeData;
      lines.push(`${indent}// Transform: ${data.expression || "payload"}`);
      lines.push(
        `${indent}const scope = { input: payload, messages: contextMessages, vars };`,
      );
      lines.push(`${indent}payload = (${data.expression || "payload"});`);
      break;
    }

    case ZoeNodeID.Redact: {
      const data = node.data as ZoeRedactNodeData;
      lines.push(`${indent}// Redact sensitive information`);
      lines.push(`${indent}let redacted = String(payload);`);
      if (data.redactEmails) {
        lines.push(
          `${indent}redacted = redacted.replace(/[\\w.-]+@[\\w.-]+\\.[\\w]+/g, ${JSON.stringify(data.replacement || "[REDACTED]")});`,
        );
      }
      if (data.redactApiKeys) {
        lines.push(
          `${indent}redacted = redacted.replace(/[a-zA-Z0-9]{32,}/g, ${JSON.stringify(data.replacement || "[REDACTED]")});`,
        );
      }
      lines.push(`${indent}payload = redacted;`);
      break;
    }

    case ZoeNodeID.Guardrails: {
      lines.push(`${indent}// Guardrails check (harm detection)`);
      lines.push(
        `${indent}// This would call guardrails API in actual execution`,
      );
      break;
    }

    case ZoeNodeID.Tool: {
      const data = node.data as ZoeToolNodeData;
      const definition = getDeveloperToolDefinition(data.toolKey);
      lines.push(`${indent}// Tool: ${definition?.label ?? data.toolKey}`);
      lines.push(`${indent}// ${definition?.description ?? ""}`);
      break;
    }

    case ZoeNodeID.End: {
      lines.push(`${indent}// End of flow`);
      break;
    }

    case ZoeNodeID.IfElse:
    case ZoeNodeID.Switch:
      // These are handled in traverseAndGenerate
      break;

    default:
      lines.push(`${indent}// Node type: ${node.type}`);
  }
}

/**
 * Group edges by their source node id.
 */
function buildEdgesBySource(edges: ZoeEdge[]) {
  const map = new Map<string, ZoeEdge[]>();
  for (const edge of edges) {
    const next = map.get(edge.source) ?? [];
    next.push(edge);
    map.set(edge.source, next);
  }
  return map;
}
